{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\nexport class ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  async connect(url, transferFormat) {\n    Arg.isRequired(url, \"url\");\n    Arg.isRequired(transferFormat, \"transferFormat\");\n    Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n    this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\n    // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n    this._url = url;\n    if (this._accessToken) {\n      url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\n    }\n    return new Promise((resolve, reject) => {\n      let opened = false;\n      if (transferFormat !== TransferFormat.Text) {\n        reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n        return;\n      }\n      let eventSource;\n      if (Platform.isBrowser || Platform.isWebWorker) {\n        eventSource = new this._options.EventSource(url, {\n          withCredentials: this._options.withCredentials\n        });\n      } else {\n        // Non-browser passes cookies via the dictionary\n        const cookies = this._httpClient.getCookieString(url);\n        const headers = {};\n        headers.Cookie = cookies;\n        const [name, value] = getUserAgentHeader();\n        headers[name] = value;\n        eventSource = new this._options.EventSource(url, {\n          withCredentials: this._options.withCredentials,\n          headers: {\n            ...headers,\n            ...this._options.headers\n          }\n        });\n      }\n      try {\n        eventSource.onmessage = e => {\n          if (this.onreceive) {\n            try {\n              this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\n              this.onreceive(e.data);\n            } catch (error) {\n              this._close(error);\n              return;\n            }\n          }\n        };\n        // @ts-ignore: not using event on purpose\n        eventSource.onerror = e => {\n          // EventSource doesn't give any useful information about server side closes.\n          if (opened) {\n            this._close();\n          } else {\n            reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n          }\n        };\n        eventSource.onopen = () => {\n          this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\n          this._eventSource = eventSource;\n          opened = true;\n          resolve();\n        };\n      } catch (e) {\n        reject(e);\n        return;\n      }\n    });\n  }\n  async send(data) {\n    if (!this._eventSource) {\n      return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n    }\n    return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\n  }\n  stop() {\n    this._close();\n    return Promise.resolve();\n  }\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n      this._eventSource = undefined;\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n}","map":{"version":3,"names":["LogLevel","TransferFormat","Arg","getDataDetail","getUserAgentHeader","Platform","sendMessage","ServerSentEventsTransport","constructor","httpClient","accessToken","logger","options","_httpClient","_accessToken","_logger","_options","onreceive","onclose","connect","url","transferFormat","isRequired","isIn","log","Trace","_url","indexOf","encodeURIComponent","Promise","resolve","reject","opened","Text","Error","eventSource","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","name","value","onmessage","e","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","send","stop","close","undefined"],"sources":["/home/oneeightseven/Рабочий стол/WebTech/Webtech.Frontend/node_modules/@microsoft/signalr/src/ServerSentEventsTransport.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessToken: string | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private _eventSource?: EventSource;\r\n    private _url?: string;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error | unknown) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessToken: string | undefined, logger: ILogger,\r\n                options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent!)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e: Event) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    } else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(e?: Error | unknown) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}