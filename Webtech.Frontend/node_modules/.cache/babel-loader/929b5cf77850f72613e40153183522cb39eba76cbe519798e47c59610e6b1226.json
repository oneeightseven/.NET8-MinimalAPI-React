{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { HttpClient } from \"./HttpClient\";\n/** @private */\nexport class AccessTokenHttpClient extends HttpClient {\n  constructor(innerClient, accessTokenFactory) {\n    super();\n    this._innerClient = innerClient;\n    this._accessTokenFactory = accessTokenFactory;\n  }\n  async send(request) {\n    let allowRetry = true;\n    if (this._accessTokenFactory && (!this._accessToken || request.url && request.url.indexOf(\"/negotiate?\") > 0)) {\n      // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n      allowRetry = false;\n      this._accessToken = await this._accessTokenFactory();\n    }\n    this._setAuthorizationHeader(request);\n    const response = await this._innerClient.send(request);\n    if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\n      this._accessToken = await this._accessTokenFactory();\n      this._setAuthorizationHeader(request);\n      return await this._innerClient.send(request);\n    }\n    return response;\n  }\n  _setAuthorizationHeader(request) {\n    if (!request.headers) {\n      request.headers = {};\n    }\n    if (this._accessToken) {\n      request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\n    }\n    // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n    else if (this._accessTokenFactory) {\n      if (request.headers[HeaderNames.Authorization]) {\n        delete request.headers[HeaderNames.Authorization];\n      }\n    }\n  }\n  getCookieString(url) {\n    return this._innerClient.getCookieString(url);\n  }\n}","map":{"version":3,"names":["HeaderNames","HttpClient","AccessTokenHttpClient","constructor","innerClient","accessTokenFactory","_innerClient","_accessTokenFactory","send","request","allowRetry","_accessToken","url","indexOf","_setAuthorizationHeader","response","statusCode","headers","Authorization","getCookieString"],"sources":["/home/oneeightseven/webtech/node_modules/@microsoft/signalr/src/AccessTokenHttpClient.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\n\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    private _innerClient: HttpClient;\r\n    _accessToken: string | undefined;\r\n    _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n\r\n    constructor(innerClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined) {\r\n        super();\r\n\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    private _setAuthorizationHeader(request: HttpRequest) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}"],"mappings":"AAAA;AACA;AAEA,SAASA,WAAW,QAAQ,eAAe;AAC3C,SAASC,UAAU,QAAmC,cAAc;AAEpE;AACA,OAAM,MAAOC,qBAAsB,SAAQD,UAAU;EAKjDE,YAAYC,WAAuB,EAAEC,kBAAgE;IACjG,KAAK,EAAE;IAEP,IAAI,CAACC,YAAY,GAAGF,WAAW;IAC/B,IAAI,CAACG,mBAAmB,GAAGF,kBAAkB;EACjD;EAEO,MAAMG,IAAIA,CAACC,OAAoB;IAClC,IAAIC,UAAU,GAAG,IAAI;IACrB,IAAI,IAAI,CAACH,mBAAmB,KAAK,CAAC,IAAI,CAACI,YAAY,IAAKF,OAAO,CAACG,GAAG,IAAIH,OAAO,CAACG,GAAG,CAACC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAE,CAAC,EAAE;MAC7G;MACAH,UAAU,GAAG,KAAK;MAClB,IAAI,CAACC,YAAY,GAAG,MAAM,IAAI,CAACJ,mBAAmB,EAAE;;IAExD,IAAI,CAACO,uBAAuB,CAACL,OAAO,CAAC;IACrC,MAAMM,QAAQ,GAAG,MAAM,IAAI,CAACT,YAAY,CAACE,IAAI,CAACC,OAAO,CAAC;IAEtD,IAAIC,UAAU,IAAIK,QAAQ,CAACC,UAAU,KAAK,GAAG,IAAI,IAAI,CAACT,mBAAmB,EAAE;MACvE,IAAI,CAACI,YAAY,GAAG,MAAM,IAAI,CAACJ,mBAAmB,EAAE;MACpD,IAAI,CAACO,uBAAuB,CAACL,OAAO,CAAC;MACrC,OAAO,MAAM,IAAI,CAACH,YAAY,CAACE,IAAI,CAACC,OAAO,CAAC;;IAEhD,OAAOM,QAAQ;EACnB;EAEQD,uBAAuBA,CAACL,OAAoB;IAChD,IAAI,CAACA,OAAO,CAACQ,OAAO,EAAE;MAClBR,OAAO,CAACQ,OAAO,GAAG,EAAE;;IAExB,IAAI,IAAI,CAACN,YAAY,EAAE;MACnBF,OAAO,CAACQ,OAAO,CAACjB,WAAW,CAACkB,aAAa,CAAC,GAAG,UAAU,IAAI,CAACP,YAAY,EAAE;;IAE9E;IAAA,KACK,IAAI,IAAI,CAACJ,mBAAmB,EAAE;MAC/B,IAAIE,OAAO,CAACQ,OAAO,CAACjB,WAAW,CAACkB,aAAa,CAAC,EAAE;QAC5C,OAAOT,OAAO,CAACQ,OAAO,CAACjB,WAAW,CAACkB,aAAa,CAAC;;;EAG7D;EAEOC,eAAeA,CAACP,GAAW;IAC9B,OAAO,IAAI,CAACN,YAAY,CAACa,eAAe,CAACP,GAAG,CAAC;EACjD"},"metadata":{},"sourceType":"module","externalDependencies":[]}