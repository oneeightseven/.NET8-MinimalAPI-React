{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { MessageType } from \"./IHubProtocol\";\nimport { isArrayBuffer } from \"./Utils\";\n/** @private */\nexport class MessageBuffer {\n  constructor(protocol, connection, bufferSize) {\n    this._bufferSize = 100000;\n    this._messages = [];\n    this._totalMessageCount = 0;\n    this._waitForSequenceMessage = false;\n    // Message IDs start at 1 and always increment by 1\n    this._nextReceivingSequenceId = 1;\n    this._latestReceivedSequenceId = 0;\n    this._bufferedByteCount = 0;\n    this._reconnectInProgress = false;\n    this._protocol = protocol;\n    this._connection = connection;\n    this._bufferSize = bufferSize;\n  }\n  async _send(message) {\n    const serializedMessage = this._protocol.writeMessage(message);\n    let backpressurePromise = Promise.resolve();\n    // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\n    if (this._isInvocationMessage(message)) {\n      this._totalMessageCount++;\n      let backpressurePromiseResolver = () => {};\n      let backpressurePromiseRejector = () => {};\n      if (isArrayBuffer(serializedMessage)) {\n        this._bufferedByteCount += serializedMessage.byteLength;\n      } else {\n        this._bufferedByteCount += serializedMessage.length;\n      }\n      if (this._bufferedByteCount >= this._bufferSize) {\n        backpressurePromise = new Promise((resolve, reject) => {\n          backpressurePromiseResolver = resolve;\n          backpressurePromiseRejector = reject;\n        });\n      }\n      this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\n    }\n    try {\n      // If this is set it means we are reconnecting or resending\n      // We don't want to send on a disconnected connection\n      // And we don't want to send if resend is running since that would mean sending\n      // this message twice\n      if (!this._reconnectInProgress) {\n        await this._connection.send(serializedMessage);\n      }\n    } catch {\n      this._disconnected();\n    }\n    await backpressurePromise;\n  }\n  _ack(ackMessage) {\n    let newestAckedMessage = -1;\n    // Find index of newest message being acked\n    for (let index = 0; index < this._messages.length; index++) {\n      const element = this._messages[index];\n      if (element._id <= ackMessage.sequenceId) {\n        newestAckedMessage = index;\n        if (isArrayBuffer(element._message)) {\n          this._bufferedByteCount -= element._message.byteLength;\n        } else {\n          this._bufferedByteCount -= element._message.length;\n        }\n        // resolve items that have already been sent and acked\n        element._resolver();\n      } else if (this._bufferedByteCount < this._bufferSize) {\n        // resolve items that now fall under the buffer limit but haven't been acked\n        element._resolver();\n      } else {\n        break;\n      }\n    }\n    if (newestAckedMessage !== -1) {\n      // We're removing everything including the message pointed to, so add 1\n      this._messages = this._messages.slice(newestAckedMessage + 1);\n    }\n  }\n  _shouldProcessMessage(message) {\n    if (this._waitForSequenceMessage) {\n      if (message.type !== MessageType.Sequence) {\n        return false;\n      } else {\n        this._waitForSequenceMessage = false;\n        return true;\n      }\n    }\n    // No special processing for acks, pings, etc.\n    if (!this._isInvocationMessage(message)) {\n      return true;\n    }\n    const currentId = this._nextReceivingSequenceId;\n    this._nextReceivingSequenceId++;\n    if (currentId <= this._latestReceivedSequenceId) {\n      if (currentId === this._latestReceivedSequenceId) {\n        // Should only hit this if we just reconnected and the server is sending\n        // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\n        this._ackTimer();\n      }\n      // Ignore, this is a duplicate message\n      return false;\n    }\n    this._latestReceivedSequenceId = currentId;\n    // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\n    // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\n    this._ackTimer();\n    return true;\n  }\n  _resetSequence(message) {\n    if (message.sequenceId > this._nextReceivingSequenceId) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\n      return;\n    }\n    this._nextReceivingSequenceId = message.sequenceId;\n  }\n  _disconnected() {\n    this._reconnectInProgress = true;\n    this._waitForSequenceMessage = true;\n  }\n  async _resend() {\n    const sequenceId = this._messages.length !== 0 ? this._messages[0]._id : this._totalMessageCount + 1;\n    await this._connection.send(this._protocol.writeMessage({\n      type: MessageType.Sequence,\n      sequenceId\n    }));\n    // Get a local variable to the _messages, just in case messages are acked while resending\n    // Which would slice the _messages array (which creates a new copy)\n    const messages = this._messages;\n    for (const element of messages) {\n      await this._connection.send(element._message);\n    }\n    this._reconnectInProgress = false;\n  }\n  _dispose(error) {\n    error !== null && error !== void 0 ? error : error = new Error(\"Unable to reconnect to server.\");\n    // Unblock backpressure if any\n    for (const element of this._messages) {\n      element._rejector(error);\n    }\n  }\n  _isInvocationMessage(message) {\n    // There is no way to check if something implements an interface.\n    // So we individually check the messages in a switch statement.\n    // To make sure we don't miss any message types we rely on the compiler\n    // seeing the function returns a value and it will do the\n    // exhaustive check for us on the switch statement, since we don't use 'case default'\n    switch (message.type) {\n      case MessageType.Invocation:\n      case MessageType.StreamItem:\n      case MessageType.Completion:\n      case MessageType.StreamInvocation:\n      case MessageType.CancelInvocation:\n        return true;\n      case MessageType.Close:\n      case MessageType.Sequence:\n      case MessageType.Ping:\n      case MessageType.Ack:\n        return false;\n    }\n  }\n  _ackTimer() {\n    if (this._ackTimerHandle === undefined) {\n      this._ackTimerHandle = setTimeout(async () => {\n        try {\n          if (!this._reconnectInProgress) {\n            await this._connection.send(this._protocol.writeMessage({\n              type: MessageType.Ack,\n              sequenceId: this._latestReceivedSequenceId\n            }));\n          }\n          // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\n        } catch {}\n        clearTimeout(this._ackTimerHandle);\n        this._ackTimerHandle = undefined;\n        // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\n      }, 1000);\n    }\n  }\n}\nclass BufferedItem {\n  constructor(message, id, resolver, rejector) {\n    this._message = message;\n    this._id = id;\n    this._resolver = resolver;\n    this._rejector = rejector;\n  }\n}","map":{"version":3,"names":["MessageType","isArrayBuffer","MessageBuffer","constructor","protocol","connection","bufferSize","_bufferSize","_messages","_totalMessageCount","_waitForSequenceMessage","_nextReceivingSequenceId","_latestReceivedSequenceId","_bufferedByteCount","_reconnectInProgress","_protocol","_connection","_send","message","serializedMessage","writeMessage","backpressurePromise","Promise","resolve","_isInvocationMessage","backpressurePromiseResolver","backpressurePromiseRejector","byteLength","length","reject","push","BufferedItem","send","_disconnected","_ack","ackMessage","newestAckedMessage","index","element","_id","sequenceId","_message","_resolver","slice","_shouldProcessMessage","type","Sequence","currentId","_ackTimer","_resetSequence","stop","Error","_resend","messages","_dispose","error","_rejector","Invocation","StreamItem","Completion","StreamInvocation","CancelInvocation","Close","Ping","Ack","_ackTimerHandle","undefined","setTimeout","clearTimeout","id","resolver","rejector"],"sources":["/home/oneeightseven/Рабочий стол/WebTech/Webtech.Frontend/node_modules/@microsoft/signalr/src/MessageBuffer.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IConnection } from \"./IConnection\";\r\nimport { AckMessage, HubMessage, IHubProtocol, MessageType, SequenceMessage } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class MessageBuffer {\r\n    private readonly _protocol: IHubProtocol;\r\n    private readonly _connection: IConnection;\r\n\r\n    private readonly _bufferSize: number = 100_000;\r\n\r\n    private _messages: BufferedItem[] = [];\r\n    private _totalMessageCount: number = 0;\r\n    private _waitForSequenceMessage: boolean = false;\r\n\r\n    // Message IDs start at 1 and always increment by 1\r\n    private _nextReceivingSequenceId = 1;\r\n    private _latestReceivedSequenceId = 0;\r\n    private _bufferedByteCount: number = 0;\r\n    private _reconnectInProgress: boolean = false;\r\n\r\n    private _ackTimerHandle?: any;\r\n\r\n    constructor(protocol: IHubProtocol, connection: IConnection, bufferSize: number) {\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n\r\n    public async _send(message: HubMessage): Promise<void> {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n\r\n        let backpressurePromise: Promise<void> = Promise.resolve();\r\n\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver: (value: void) => void = () => {};\r\n            let backpressurePromiseRejector: (value?: void) => void = () => {};\r\n\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            } else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount,\r\n                backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        } catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n\r\n    public _ack(ackMessage: AckMessage): void {\r\n        let newestAckedMessage = -1;\r\n\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                } else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            } else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n\r\n    public _shouldProcessMessage(message: HubMessage): boolean {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            } else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n\r\n        this._latestReceivedSequenceId = currentId;\r\n\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n\r\n    public _resetSequence(message: SequenceMessage): void {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n\r\n    public _disconnected(): void {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n\r\n    public async _resend(): Promise<void> {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            :  this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n\r\n        this._reconnectInProgress = false;\r\n    }\r\n\r\n    public _dispose(error?: Error): void {\r\n        error ??= new Error(\"Unable to reconnect to server.\")\r\n\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n\r\n    private _isInvocationMessage(message: HubMessage): boolean {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    private _ackTimer(): void {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }))\r\n                    }\r\n                // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                } catch { }\r\n\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n            // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\n\r\nclass BufferedItem {\r\n    constructor(message: string | ArrayBuffer, id: number, resolver: (value: void) => void, rejector: (value?: any) => void) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n\r\n    _message: string | ArrayBuffer;\r\n    _id: number;\r\n    _resolver: (value: void) => void;\r\n    _rejector: (value?: any) => void;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}